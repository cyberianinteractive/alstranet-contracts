// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

/**
 * @title TerritoryLibrary
 * @dev Library of functions for handling territory-related calculations in the Police & Thief ecosystem.
 *      This library contains pure functions that handle territory value calculation, resource generation,
 *      contested status determination, economic impact calculations, and territory relationship mapping.
 */
library TerritoryLibrary {
    // Constants for territory zone types
    uint8 public constant HIGH_SECURITY_ZONE = 1;
    uint8 public constant MEDIUM_SECURITY_ZONE = 2;
    uint8 public constant NO_GO_ZONE = 3;

    // Constants for calculating territory values
    uint256 public constant CONTESTED_PENALTY_PERCENT = 20; // 20% value reduction when contested
    uint256 public constant RESOURCE_VALUE_MULTIPLIER = 10; // Multiplier for resource value
    uint256 public constant BLOCK_TIME_SECONDS = 2; // AlstraNet block time in seconds

    /**
     * @dev Calculates the current economic value of a territory based on various factors
     * @param baseValue The base economic value assigned to the territory
     * @param zoneType The type of zone (1=High-Security, 2=Medium-Security, 3=No-Go)
     * @param resourceRate The resource generation rate of the territory
     * @param contestedStatus Whether the territory is currently contested
     * @param lastUpdateBlock The last block when the territory state was updated
     * @param currentBlock The current block number
     * @return value The calculated economic value of the territory
     */
    function calculateTerritoryValue(
        uint256 baseValue,
        uint8 zoneType,
        uint256 resourceRate,
        bool contestedStatus,
        uint256 lastUpdateBlock,
        uint256 currentBlock
    ) public pure returns (uint256 value) {
        // Start with the base value
        value = baseValue;
        
        // Apply zone type multipliers
        if (zoneType == HIGH_SECURITY_ZONE) {
            // High security zones get a premium for safety
            value = value * 120 / 100; // 20% premium
        } else if (zoneType == NO_GO_ZONE) {
            // No-go zones have higher risk but potentially higher rewards
            value = value * 80 / 100; // 20% discount, but higher resource rate typically
        }
        
        // Add value from accumulated resources since last update
        uint256 resourcesGenerated = calculateGeneratedResources(
            resourceRate,
            lastUpdateBlock,
            currentBlock,
            100 // 100% control assumed for basic calculation
        );
        
        value += resourcesGenerated * RESOURCE_VALUE_MULTIPLIER;
        
        // Apply contested status penalty if contested
        if (contestedStatus) {
            value = value * (100 - CONTESTED_PENALTY_PERCENT) / 100;
        }
        
        return value;
    }

    /**
     * @dev Calculates resources generated by a territory since last update
     * @param resourceRate Base resource generation rate per block
     * @param lastUpdateBlock Last block when resources were calculated
     * @param currentBlock Current block number
     * @param controlModifier Modifier based on controlling faction's efficiency (0-100)
     * @return The amount of resources generated
     */
    function calculateGeneratedResources(
        uint256 resourceRate,
        uint256 lastUpdateBlock,
        uint256 currentBlock,
        uint8 controlModifier
    ) public pure returns (uint256) {
        // Ensure we don't calculate for future blocks
        if (currentBlock <= lastUpdateBlock) {
            return 0;
        }
        
        // Calculate blocks elapsed
        uint256 blocksElapsed = currentBlock - lastUpdateBlock;
        
        // Calculate base resources generated
        uint256 baseResources = resourceRate * blocksElapsed;
        
        // Apply control modifier (efficiency of the controlling faction)
        return (baseResources * controlModifier) / 100;
    }

    /**
     * @dev Determines if a territory is contested based on faction stakes
     * @param factionStakes Array of stake amounts by faction (indexed by faction ID, 0 index unused)
     * @param totalStaked Total amount staked on the territory
     * @param contestThreshold Percentage threshold for contested state (e.g., 5 = 5%)
     * @return isContested Whether the territory is contested
     * @return dominantFaction The faction with the highest stake (0 if none)
     * @return challengerFaction The faction with the second highest stake (0 if none)
     */
    function determineContestedStatus(
        uint256[] memory factionStakes,
        uint256 totalStaked,
        uint8 contestThreshold
    ) public pure returns (
        bool isContested,
        uint8 dominantFaction,
        uint8 challengerFaction
    ) {
        // Return early if no stakes
        if (totalStaked == 0) {
            return (false, 0, 0);
        }
        
        // Find dominant and challenger factions
        uint256 highestStake = 0;
        uint256 secondHighestStake = 0;
        
        // Start from index 1 since faction IDs start from 1
        for (uint8 i = 1; i < factionStakes.length; i++) {
            if (factionStakes[i] > highestStake) {
                // Current highest becomes second highest
                secondHighestStake = highestStake;
                challengerFaction = dominantFaction;
                
                // New highest
                highestStake = factionStakes[i];
                dominantFaction = i;
            } else if (factionStakes[i] > secondHighestStake) {
                // New second highest
                secondHighestStake = factionStakes[i];
                challengerFaction = i;
            }
        }
        
        // Calculate the dominant faction's control percentage
        uint256 dominantPercentage = (highestStake * 100) / totalStaked;
        
        // Calculate the challenger faction's percentage
        uint256 challengerPercentage = (secondHighestStake * 100) / totalStaked;
        
        // A territory is contested if the gap between dominant and challenger
        // is less than the contest threshold
        if (dominantPercentage < 50 || (dominantPercentage - challengerPercentage) < contestThreshold) {
            isContested = true;
        }
        
        return (isContested, dominantFaction, challengerFaction);
    }

    /**
     * @dev Calculates the economic impact of a territory on a given faction
     * @param factionId The faction ID to calculate impact for
     * @param controllingFaction The faction currently controlling the territory
     * @param isContested Whether the territory is contested
     * @param baseImpact Base economic impact value of the territory
     * @param factionPresencePercentage Percentage of faction's presence in the territory (0-100)
     * @return The calculated economic impact value
     */
    function calculateEconomicImpact(
        uint8 factionId,
        uint8 controllingFaction,
        bool isContested,
        uint256 baseImpact,
        uint8 factionPresencePercentage
    ) public pure returns (uint256) {
        // Base impact proportional to presence
        uint256 impact = (baseImpact * factionPresencePercentage) / 100;
        
        // If this faction controls the territory, they get a bonus
        if (factionId == controllingFaction && !isContested) {
            impact = impact * 150 / 100; // 50% bonus for controlling
        }
        
        // If territory is contested, reduce the impact for everyone
        if (isContested) {
            impact = impact * 75 / 100; // 25% reduction when contested
        }
        
        return impact;
    }

    /**
     * @dev Calculates the tax rate for a territory based on zone type and controlling faction
     * @param zoneType The type of zone (1=High-Security, 2=Medium-Security, 3=No-Go)
     * @param controllingFaction The faction controlling the territory (0=None, 1=Law, 2=Criminal, 3=Vigilante)
     * @param isContested Whether the territory is contested
     * @return The tax rate in basis points (100 = 1%)
     */
    function calculateTerritoryTaxRate(
        uint8 zoneType,
        uint8 controllingFaction,
        bool isContested
    ) public pure returns (uint256) {
        // Base rates by zone type (in basis points)
        uint256 baseTaxRate;
        
        if (zoneType == HIGH_SECURITY_ZONE) {
            baseTaxRate = 500; // 5% for high security zones
        } else if (zoneType == MEDIUM_SECURITY_ZONE) {
            baseTaxRate = 300; // 3% for medium security zones
        } else if (zoneType == NO_GO_ZONE) {
            baseTaxRate = 100; // 1% for no-go zones (higher risk, lower tax)
        } else {
            baseTaxRate = 300; // Default 3%
        }
        
        // Adjust based on controlling faction
        if (controllingFaction == 1) { // Law Enforcement
            baseTaxRate = baseTaxRate * 120 / 100; // 20% higher taxes
        } else if (controllingFaction == 2) { // Criminal
            baseTaxRate = baseTaxRate * 50 / 100; // 50% lower taxes (black market)
        } else if (controllingFaction == 3) { // Vigilante
            baseTaxRate = baseTaxRate * 80 / 100; // 20% lower taxes (community support)
        }
        
        // Contested territories have volatile tax rates
        if (isContested) {
            baseTaxRate = baseTaxRate * 130 / 100; // 30% higher due to instability
        }
        
        return baseTaxRate;
    }

    /**
     * @dev Determines if two territories are connected for gameplay purposes
     * @param distanceScore A measure of the geographic distance between territories (lower is closer)
     * @param hasBorderConnection Whether the territories share a border
     * @param territoryAZoneType Zone type of first territory
     * @param territoryBZoneType Zone type of second territory
     * @return A connection score (0 = not connected, higher = stronger connection)
     */
    function calculateTerritoryConnection(
        uint256 distanceScore,
        bool hasBorderConnection,
        uint8 territoryAZoneType,
        uint8 territoryBZoneType
    ) public pure returns (uint8) {
        // Not connected if distance is too great
        if (distanceScore > 100) {
            return 0;
        }
        
        // Base connection score inversely proportional to distance
        uint8 connectionScore = uint8(100 - distanceScore);
        
        // Border connection significantly increases the connection strength
        if (hasBorderConnection) {
            connectionScore += 50;
        }
        
        // Zone type compatibility affects connection (similar zones connect better)
        if (territoryAZoneType == territoryBZoneType) {
            connectionScore += 20; // Same zone types connect well
        } else if (
            (territoryAZoneType == HIGH_SECURITY_ZONE && territoryBZoneType == NO_GO_ZONE) || 
            (territoryBZoneType == HIGH_SECURITY_ZONE && territoryAZoneType == NO_GO_ZONE)
        ) {
            // High security and no-go zones don't connect well
            connectionScore = connectionScore > 30 ? connectionScore - 30 : 0;
        }
        
        return connectionScore > 100 ? 100 : connectionScore;
    }

    /**
     * @dev Maps territory geographical connections to adjacency list format
     * @param territoryCount The total number of territories
     * @param connectionScores 2D array of connection scores between territories
     * @param minimumConnectionStrength Minimum score to consider territories connected
     * @return adjacencyList An array of arrays where each inner array contains IDs of connected territories
     * @return connectionStrengths 2D array with connection strength between connected territories
     */
    function mapTerritoryConnections(
        uint256 territoryCount,
        uint8[][] memory connectionScores,
        uint8 minimumConnectionStrength
    ) public pure returns (
        uint256[][] memory adjacencyList,
        uint8[][] memory connectionStrengths
    ) {
        // Initialize adjacency list and strengths
        adjacencyList = new uint256[][](territoryCount);
        connectionStrengths = new uint8[][](territoryCount);
        
        // Count connections for each territory first to size arrays correctly
        uint256[] memory connectionCounts = new uint256[](territoryCount);
        
        for (uint256 i = 0; i < territoryCount; i++) {
            uint256 count = 0;
            for (uint256 j = 0; j < territoryCount; j++) {
                if (i != j && connectionScores[i][j] >= minimumConnectionStrength) {
                    count++;
                }
            }
            connectionCounts[i] = count;
            
            // Initialize inner arrays with correct size
            adjacencyList[i] = new uint256[](count);
            connectionStrengths[i] = new uint8[](count);
        }
        
        // Fill the adjacency list and connection strengths
        for (uint256 i = 0; i < territoryCount; i++) {
            uint256 index = 0;
            for (uint256 j = 0; j < territoryCount; j++) {
                if (i != j && connectionScores[i][j] >= minimumConnectionStrength) {
                    adjacencyList[i][index] = j;
                    connectionStrengths[i][index] = connectionScores[i][j];
                    index++;
                }
            }
        }
        
        return (adjacencyList, connectionStrengths);
    }

    /**
     * @dev Calculates resource flow between connected territories
     * @param territoryResourceRates Array of resource generation rates for each territory
     * @param adjacencyList Adjacency list representation of territory connections
     * @param connectionStrengths Connection strength between territories
     * @param flowPercentage The percentage of resources that flow between connected territories (0-100)
     * @return resourceFlows Net resource flow for each territory (positive means inflow)
     */
    function calculateResourceFlow(
        uint256[] memory territoryResourceRates,
        uint256[][] memory adjacencyList,
        uint8[][] memory connectionStrengths,
        uint8 flowPercentage
    ) public pure returns (int256[] memory resourceFlows) {
        uint256 territoryCount = territoryResourceRates.length;
        resourceFlows = new int256[](territoryCount);
        
        // Calculate outflows and inflows
        for (uint256 i = 0; i < territoryCount; i++) {
            // For each territory, calculate resource flow to connected territories
            for (uint256 j = 0; j < adjacencyList[i].length; j++) {
                uint256 connectedTerritory = adjacencyList[i][j];
                uint8 connectionStrength = connectionStrengths[i][j];
                
                // Calculate flow based on resource rate, connection strength, and flow percentage
                uint256 flow = territoryResourceRates[i] * connectionStrength * flowPercentage / 10000; // Divide by 100*100
                
                // Adjust the net flow for both territories
                resourceFlows[i] -= int256(flow); // Outflow from current territory
                resourceFlows[connectedTerritory] += int256(flow); // Inflow to connected territory
            }
        }
        
        return resourceFlows;
    }
}