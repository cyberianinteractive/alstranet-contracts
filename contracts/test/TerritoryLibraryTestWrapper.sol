// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "../protocol/libraries/TerritoryLibrary.sol";

/**
 * @title TerritoryLibraryTestWrapper
 * @dev A wrapper contract that exposes TerritoryLibrary's internal functions for testing purposes.
 *      This wrapper enables unit testing of TerritoryLibrary's internal functions by providing
 *      public versions that simply pass through to the library implementation.
 *
 *      IMPORTANT: This contract is for TESTING ONLY and should never be deployed in production.
 */
contract TerritoryLibraryTestWrapper {
    // =========================================================================
    // Constants - expose library constants through getter functions
    // =========================================================================

    /**
     * @dev Returns the HIGH_SECURITY_ZONE constant
     * @return The value of TerritoryLibrary.HIGH_SECURITY_ZONE
     */
    function HIGH_SECURITY_ZONE() external pure returns (uint8) {
        return TerritoryLibrary.HIGH_SECURITY_ZONE;
    }

    /**
     * @dev Returns the MEDIUM_SECURITY_ZONE constant
     * @return The value of TerritoryLibrary.MEDIUM_SECURITY_ZONE
     */
    function MEDIUM_SECURITY_ZONE() external pure returns (uint8) {
        return TerritoryLibrary.MEDIUM_SECURITY_ZONE;
    }

    /**
     * @dev Returns the NO_GO_ZONE constant
     * @return The value of TerritoryLibrary.NO_GO_ZONE
     */
    function NO_GO_ZONE() external pure returns (uint8) {
        return TerritoryLibrary.NO_GO_ZONE;
    }

    /**
     * @dev Returns the CONTESTED_PENALTY_PERCENT constant
     * @return The value of TerritoryLibrary.CONTESTED_PENALTY_PERCENT
     */
    function CONTESTED_PENALTY_PERCENT() external pure returns (uint256) {
        return TerritoryLibrary.CONTESTED_PENALTY_PERCENT;
    }

    /**
     * @dev Returns the RESOURCE_VALUE_MULTIPLIER constant
     * @return The value of TerritoryLibrary.RESOURCE_VALUE_MULTIPLIER
     */
    function RESOURCE_VALUE_MULTIPLIER() external pure returns (uint256) {
        return TerritoryLibrary.RESOURCE_VALUE_MULTIPLIER;
    }

    /**
     * @dev Returns the BLOCK_TIME_SECONDS constant
     * @return The value of TerritoryLibrary.BLOCK_TIME_SECONDS
     */
    function BLOCK_TIME_SECONDS() external pure returns (uint256) {
        return TerritoryLibrary.BLOCK_TIME_SECONDS;
    }

    // =========================================================================
    // Territory Value Calculation Functions
    // =========================================================================

    /**
     * @dev Wrapper for TerritoryLibrary.calculateTerritoryValue
     * Calculates the current economic value of a territory based on various factors
     *
     * @param baseValue The base economic value assigned to the territory
     * @param zoneType The type of zone (1=High-Security, 2=Medium-Security, 3=No-Go)
     * @param resourceRate The resource generation rate of the territory
     * @param contestedStatus Whether the territory is currently contested
     * @param lastUpdateBlock The last block when the territory state was updated
     * @param currentBlock The current block number
     * @return value The calculated economic value of the territory
     */
    function calculateTerritoryValue(
        uint256 baseValue,
        uint8 zoneType,
        uint256 resourceRate,
        bool contestedStatus,
        uint256 lastUpdateBlock,
        uint256 currentBlock
    ) external pure returns (uint256) {
        // Just pass through to the library function
        return
            TerritoryLibrary.calculateTerritoryValue(
                baseValue,
                zoneType,
                resourceRate,
                contestedStatus,
                lastUpdateBlock,
                currentBlock
            );
    }

    /**
     * @dev Wrapper for TerritoryLibrary.calculateGeneratedResources
     * Calculates resources generated by a territory since last update
     *
     * @param resourceRate Base resource generation rate per block
     * @param lastUpdateBlock Last block when resources were calculated
     * @param currentBlock Current block number
     * @param controlModifier Modifier based on controlling faction's efficiency (0-100)
     * @return The amount of resources generated
     */
    function calculateGeneratedResources(
        uint256 resourceRate,
        uint256 lastUpdateBlock,
        uint256 currentBlock,
        uint8 controlModifier
    ) external pure returns (uint256) {
        // Just pass through to the library function
        return
            TerritoryLibrary.calculateGeneratedResources(
                resourceRate,
                lastUpdateBlock,
                currentBlock,
                controlModifier
            );
    }

    // =========================================================================
    // Territory Control and Contest Functions
    // =========================================================================

    /**
     * @dev Wrapper for TerritoryLibrary.determineContestedStatus
     * Determines if a territory is contested based on faction stakes
     *
     * @param factionStakes Array of stake amounts by faction (indexed by faction ID, 0 index unused)
     * @param totalStaked Total amount staked on the territory
     * @param contestThreshold Percentage threshold for contested state (e.g., 5 = 5%)
     * @return isContested Whether the territory is contested
     * @return dominantFaction The faction with the highest stake (0 if none)
     * @return challengerFaction The faction with the second highest stake (0 if none)
     */
    function determineContestedStatus(
        uint256[] memory factionStakes,
        uint256 totalStaked,
        uint8 contestThreshold
    )
        external
        pure
        returns (
            bool isContested,
            uint8 dominantFaction,
            uint8 challengerFaction
        )
    {
        // Just pass through to the library function
        return
            TerritoryLibrary.determineContestedStatus(
                factionStakes,
                totalStaked,
                contestThreshold
            );
    }

    // =========================================================================
    // Economic Impact and Tax Functions
    // =========================================================================

    /**
     * @dev Wrapper for TerritoryLibrary.calculateEconomicImpact
     * Calculates the economic impact of a territory on a given faction
     *
     * @param factionId The faction ID to calculate impact for
     * @param controllingFaction The faction currently controlling the territory
     * @param isContested Whether the territory is contested
     * @param baseImpact Base economic impact value of the territory
     * @param factionPresencePercentage Percentage of faction's presence in the territory (0-100)
     * @return The calculated economic impact value
     */
    function calculateEconomicImpact(
        uint8 factionId,
        uint8 controllingFaction,
        bool isContested,
        uint256 baseImpact,
        uint8 factionPresencePercentage
    ) external pure returns (uint256) {
        // Just pass through to the library function
        return
            TerritoryLibrary.calculateEconomicImpact(
                factionId,
                controllingFaction,
                isContested,
                baseImpact,
                factionPresencePercentage
            );
    }

    /**
     * @dev Wrapper for TerritoryLibrary.calculateTerritoryTaxRate
     * Calculates the tax rate for a territory based on zone type and controlling faction
     *
     * @param zoneType The type of zone (1=High-Security, 2=Medium-Security, 3=No-Go)
     * @param controllingFaction The faction controlling the territory (0=None, 1=Law, 2=Criminal, 3=Vigilante)
     * @param isContested Whether the territory is contested
     * @return The tax rate in basis points (100 = 1%)
     */
    function calculateTerritoryTaxRate(
        uint8 zoneType,
        uint8 controllingFaction,
        bool isContested
    ) external pure returns (uint256) {
        // Just pass through to the library function
        return
            TerritoryLibrary.calculateTerritoryTaxRate(
                zoneType,
                controllingFaction,
                isContested
            );
    }

    // =========================================================================
    // Territory Connection and Network Functions
    // =========================================================================

    /**
     * @dev Wrapper for TerritoryLibrary.calculateTerritoryConnection
     * Determines if two territories are connected for gameplay purposes
     *
     * @param distanceScore A measure of the geographic distance between territories (lower is closer)
     * @param hasBorderConnection Whether the territories share a border
     * @param territoryAZoneType Zone type of first territory
     * @param territoryBZoneType Zone type of second territory
     * @return A connection score (0 = not connected, higher = stronger connection)
     */
    function calculateTerritoryConnection(
        uint256 distanceScore,
        bool hasBorderConnection,
        uint8 territoryAZoneType,
        uint8 territoryBZoneType
    ) external pure returns (uint8) {
        // Just pass through to the library function
        return
            TerritoryLibrary.calculateTerritoryConnection(
                distanceScore,
                hasBorderConnection,
                territoryAZoneType,
                territoryBZoneType
            );
    }

    /**
     * @dev Wrapper for TerritoryLibrary.mapTerritoryConnections
     * Maps territory geographical connections to adjacency list format
     *
     * @param territoryCount The total number of territories
     * @param connectionScores 2D array of connection scores between territories
     * @param minimumConnectionStrength Minimum score to consider territories connected
     * @return adjacencyList An array of arrays where each inner array contains IDs of connected territories
     * @return connectionStrengths 2D array with connection strength between connected territories
     */
    function mapTerritoryConnections(
        uint256 territoryCount,
        uint8[][] memory connectionScores,
        uint8 minimumConnectionStrength
    )
        external
        pure
        returns (
            uint256[][] memory adjacencyList,
            uint8[][] memory connectionStrengths
        )
    {
        // Just pass through to the library function
        return
            TerritoryLibrary.mapTerritoryConnections(
                territoryCount,
                connectionScores,
                minimumConnectionStrength
            );
    }

    /**
     * @dev Wrapper for TerritoryLibrary.calculateResourceFlow
     * Calculates resource flow between connected territories
     *
     * @param territoryResourceRates Array of resource generation rates for each territory
     * @param adjacencyList Adjacency list representation of territory connections
     * @param connectionStrengths Connection strength between territories
     * @param flowPercentage The percentage of resources that flow between connected territories (0-100)
     * @return resourceFlows Net resource flow for each territory (positive means inflow)
     */
    function calculateResourceFlow(
        uint256[] memory territoryResourceRates,
        uint256[][] memory adjacencyList,
        uint8[][] memory connectionStrengths,
        uint8 flowPercentage
    ) external pure returns (int256[] memory resourceFlows) {
        // Just pass through to the library function
        return
            TerritoryLibrary.calculateResourceFlow(
                territoryResourceRates,
                adjacencyList,
                connectionStrengths,
                flowPercentage
            );
    }
}
